#!/usr/local/bin/python3
#Jeffrey Lytle's Version 1.0

import warnings
import numpy as np
import pandas as pd
import pickle
import dill
import logging
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.linear_model import LogisticRegression


#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice



class MalwareDetectionModel:
  def __init__(self):
       self.dtypes = {
                'MachineIdentifier': 'category',
                'ProductName': 'category',
                'EngineVersion': 'category', # not used
                'AppVersion': 'category', # not used
                'AvSigVersion': 'category', # not used
                'IsBeta': 'category', # not used
                'RtpStateBitfield': 'category', # not used
                'IsSxsPassiveMode': 'category', # not used
                'DefaultBrowsersIdentifier': 'category', # not used
                'AVProductStatesIdentifier': 'category', # not used
                'AVProductsInstalled': 'category', # not used
                'AVProductsEnabled': 'category', # not used
                'HasTpm': 'category', # not used
                'CountryIdentifier': 'category', # not used
                'CityIdentifier': 'category', # not used
                'OrganizationIdentifier': 'category', # not used
                'GeoNameIdentifier': 'category', # not used
                'LocaleEnglishNameIdentifier': 'category', # not used
                'Platform': 'category',
                'Processor': 'category', # not used
                'OsVer': 'category', # not used
                'OsBuild': 'category', # not used
                'OsSuite': 'category', # not used
                'OsPlatformSubRelease': 'category', # not used
                'OsBuildLab': 'category', # not used
                'SkuEdition': 'category',
                'IsProtected': 'category',
                'AutoSampleOptIn': 'category', # not used
                'PuaMode': 'category', # not used
                'SMode': 'category', # not used
                'IeVerIdentifier': 'category', # not used
                'SmartScreen': 'category', # not used
                'Firewall': 'category',
                'UacLuaenable': 'category', # not used
                'Census_MDC2FormFactor': 'category', # not used
                'Census_DeviceFamily': 'category', # not used
                'Census_OEMNameIdentifier': 'category', # not used
                'Census_OEMModelIdentifier': 'category', # not used
                'Census_ProcessorCoreCount': 'category', # not used
                'Census_ProcessorManufacturerIdentifier': 'category', # not used
                'Census_ProcessorModelIdentifier': 'category', # not used
                'Census_ProcessorClass': 'category', # not used
                'Census_PrimaryDiskTotalCapacity': 'category', # not used
                'Census_PrimaryDiskTypeName': 'category', # not used
                'Census_SystemVolumeTotalCapacity': 'category', # not used
                'Census_HasOpticalDiskDrive': 'category', # not used
                'Census_TotalPhysicalRAM': 'category', # not used
                'Census_ChassisTypeName': 'category', # not used
                'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'category', # not used
                'Census_InternalPrimaryDisplayResolutionHorizontal': 'category', # not used
                'Census_InternalPrimaryDisplayResolutionVertical': 'category', # not used
                'Census_PowerPlatformRoleName': 'category', # not used
                'Census_InternalBatteryType': 'category', # not used
                'Census_InternalBatteryNumberOfCharges': 'category', # not used
                'Census_OSVersion': 'category', # not used
                'Census_OSArchitecture': 'category', # not used
                'Census_OSBranch': 'category', # not used
                'Census_OSBuildNumber': 'category', # not used
                'Census_OSBuildRevision': 'category', # not used
                'Census_OSEdition': 'category', # not used
                'Census_OSSkuName': 'category', # not used
                'Census_OSInstallTypeName': 'category', # not used
                'Census_OSInstallLanguageIdentifier': 'category', # not used
                'Census_OSUILocaleIdentifier': 'category', # not used
                'Census_OSWUAutoUpdateOptionsName': 'category',
                'Census_IsPortableOperatingSystem': 'category', # not used
                'Census_GenuineStateName': 'category',
                'Census_ActivationChannel': 'category',
                'Census_IsFlightingInternal': 'category', # not used
                'Census_IsFlightsDisabled': 'category', # not used
                'Census_FlightRing': 'category', # not used
                'Census_ThresholdOptIn': 'category', # not used
                'Census_FirmwareManufacturerIdentifier': 'category', # not used
                'Census_FirmwareVersionIdentifier': 'category', # not used
                'Census_IsSecureBootEnabled': 'category', # not used
                'Census_IsWIMBootEnabled': 'category', # not used
                'Census_IsVirtualDevice': 'category', # not used
                'Census_IsTouchEnabled': 'category', # not used
                'Census_IsPenCapable': 'category', # not used
                'Census_IsAlwaysOnAlwaysConnectedCapable': 'category', # not used
                'Wdft_IsGamer': 'category',
                'Wdft_RegionIdentifier': 'category', # not used
                'HasDetections': 'int8'
               }
 


  def getDataTypes(self):
      print('Training Model')
      df = pd.read_csv('testfile.csv')
      pd.set_option('display.max_rows', 500)
      pd.set_option('display.max_columns', 500)
      pd.set_option('display.width', 150)
      typelist = []
      for classifications in df:
          value = df[classifications].name
          valueType = df[classifications].dtype
          if valueType == 'object':
              vlaueType = 'category'
          typelist.append("\'{0}\': \'category\', # not used".format(value, valueType))
          #typelist.append("\'{0}\': \'{1}\', # not used".format(value, valueType))
      return typelist
   

    
  def print_full(x):
      pd.set_option('display.max_rows', len(x))
      pd.set_option('display.max_columns', None)
      pd.set_option('display.width', 2000)
      pd.set_option('display.float_format', '{:20,.2f}'.format)
      pd.set_option('display.max_colwidth', -1)
      print(x)
      pd.reset_option('display.max_rows')
      pd.reset_option('display.max_columns')
      pd.reset_option('display.width')
      pd.reset_option('display.float_format')
      pd.reset_option('display.max_colwidth')
      
  #trains a model, you can access the malware_train.csv file for training your model
  # I feel the most relevant traits are 'ProductName': 'category''Platform': 'category''SkuEdition': 'category'
  #              'IsProtected': 'category''Firewall': 'category' 'Wdft_IsGamer': 'category' for target 'HasDetections': 'int8'
  def train(self):
      
      train = pd.read_csv('testfile.csv')
      
      #test = pd.read_csv(sys.argv[2])
      target = 'HasDetections'
      attributes_to_keep = ['ProductName', 'Platform', 'SkuEdition', 'IsProtected', 'Firewall',
                            'Wdft_IsGamer', 'HasDetections', 'Census_OSWUAutoUpdateOptionsName', 
                            'Census_GenuineStateName', 'Census_ActivationChannel']
      attributes = train.columns.tolist()
      #attributes.remove(target)
      
      for items in attributes:
          if items not in attributes_to_keep:
              train.drop(items, axis=1, inplace=True)
      
      pd.set_option('display.max_rows', len(train.index))
      pd.set_option('display.max_columns', None)
      pd.set_option('display.width', 2000)
      pd.set_option('display.max_colwidth', -1)
      print(train)
      
      '''
      s = pd.get_dummies(train)
      print(s)
      '''
      x = train.iloc[:,:-1].values
      y = train.iloc[:,9].values
      imputer_x = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
      #imputer_y = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
      imputer_x = imputer_x.fit(x[:,3:5])
      #imputer_y = imputer_y.fit(y[:,:])
      x[:,3:5] = imputer_x.transform(x[:,3:5])
      model = LogisticRegression()
      model.fit(x, y)
      #label_encoder_x = LabelEncoder()
      #x[:,2] = label_encoder_x.fit_transform(x[:,2])
      #print(x)
      #onehotencoder = OneHotEncoder(categorical_features=[2])
      #x = onehotencoder.fit_transform(x).toarray()
      #y[:,:] = imputer_y.transform(y[:,:])
      #label_encoder_x = LabelEncoder()
      #label_encoder_y = LabelEncoder()
      #y = label_encoder_y.fit_transform(y)
      #print(x)
      #print("@@@@@@@@@@@@@@@@@@@@@@@@")
      #print(y)

      


  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
  def predict_probablities(self, test_data):


      print('Predict malware')

      return predictions


#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
