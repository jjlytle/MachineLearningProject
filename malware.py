#Jeffrey Lytle's Version 1.0

import warnings
import numpy as np
import pandas as pd
import pickle
import dill
from sklearn import model_selection
from sklearn.linear_model import LogisticRegression
from sklearn.impute import SimpleImputer

#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice





class MalwareDetectionModel:
  def __init__(self):
       self.model = LogisticRegression()
       self.dtypes = {
                'MachineIdentifier': 'category',
                'ProductName': 'category',
                'EngineVersion': 'category', # not used
                'AppVersion': 'category', # not used
                'AvSigVersion': 'category', # not used
                'IsBeta': 'category', # not used
                'RtpStateBitfield': 'category', # not used
                'IsSxsPassiveMode': 'category', # not used
                'DefaultBrowsersIdentifier': 'category', # not used
                'AVProductStatesIdentifier': 'category', # not used
                'AVProductsInstalled': 'category', # not used
                'AVProductsEnabled': 'category', # not used
                'HasTpm': 'category', # not used
                'CountryIdentifier': 'category', # not used
                'CityIdentifier': 'category', # not used
                'OrganizationIdentifier': 'category', # not used
                'GeoNameIdentifier': 'category', # not used
                'LocaleEnglishNameIdentifier': 'category', # not used
                'Platform': 'category',
                'Processor': 'category', # not used
                'OsVer': 'category', # not used
                'OsBuild': 'category', # not used
                'OsSuite': 'category', # not used
                'OsPlatformSubRelease': 'category', # not used
                'OsBuildLab': 'category', # not used
                'SkuEdition': 'category',
                'IsProtected': 'float64',
                'AutoSampleOptIn': 'category', # not used
                'PuaMode': 'category', # not used
                'SMode': 'category', # not used
                'IeVerIdentifier': 'category', # not used
                'SmartScreen': 'category', # not used
                'Firewall': 'float64',
                'UacLuaenable': 'category', # not used
                'Census_MDC2FormFactor': 'category', # not used
                'Census_DeviceFamily': 'category', # not used
                'Census_OEMNameIdentifier': 'category', # not used
                'Census_OEMModelIdentifier': 'category', # not used
                'Census_ProcessorCoreCount': 'category', # not used
                'Census_ProcessorManufacturerIdentifier': 'category', # not used
                'Census_ProcessorModelIdentifier': 'category', # not used
                'Census_ProcessorClass': 'category', # not used
                'Census_PrimaryDiskTotalCapacity': 'category', # not used
                'Census_PrimaryDiskTypeName': 'category', # not used
                'Census_SystemVolumeTotalCapacity': 'category', # not used
                'Census_HasOpticalDiskDrive': 'category', # not used
                'Census_TotalPhysicalRAM': 'category', # not used
                'Census_ChassisTypeName': 'category', # not used
                'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'category', # not used
                'Census_InternalPrimaryDisplayResolutionHorizontal': 'category', # not used
                'Census_InternalPrimaryDisplayResolutionVertical': 'category', # not used
                'Census_PowerPlatformRoleName': 'category', # not used
                'Census_InternalBatteryType': 'category', # not used
                'Census_InternalBatteryNumberOfCharges': 'category', # not used
                'Census_OSVersion': 'category', # not used
                'Census_OSArchitecture': 'category', # not used
                'Census_OSBranch': 'category', # not used
                'Census_OSBuildNumber': 'category', # not used
                'Census_OSBuildRevision': 'category', # not used
                'Census_OSEdition': 'category', # not used
                'Census_OSSkuName': 'category', # not used
                'Census_OSInstallTypeName': 'category', # not used
                'Census_OSInstallLanguageIdentifier': 'category', # not used
                'Census_OSUILocaleIdentifier': 'category', # not used
                'Census_OSWUAutoUpdateOptionsName': 'category',
                'Census_IsPortableOperatingSystem': 'category', # not used
                'Census_GenuineStateName': 'category',
                'Census_ActivationChannel': 'category',
                'Census_IsFlightingInternal': 'category', # not used
                'Census_IsFlightsDisabled': 'category', # not used
                'Census_FlightRing': 'category', # not used
                'Census_ThresholdOptIn': 'category', # not used
                'Census_FirmwareManufacturerIdentifier': 'category', # not used
                'Census_FirmwareVersionIdentifier': 'category', # not used
                'Census_IsSecureBootEnabled': 'category', # not used
                'Census_IsWIMBootEnabled': 'category', # not used
                'Census_IsVirtualDevice': 'category', # not used
                'Census_IsTouchEnabled': 'category', # not used
                'Census_IsPenCapable': 'category', # not used
                'Census_IsAlwaysOnAlwaysConnectedCapable': 'category', # not used
                'Wdft_IsGamer': 'category',
                'Wdft_RegionIdentifier': 'category', # not used
                'HasDetections': 'int8'
               }
       
       
 



  #trains a model, you can access the malware_train.csv file for training your model
  def train(self):

     print('Train Model')

     train = pd.read_csv('testfile.csv')
      
     #test = pd.read_csv(sys.argv[2])
     target = 'HasDetections'
     attributes_to_keep = ['ProductName', 'Platform', 'SkuEdition', 'IsProtected', 'Firewall',
                            'Wdft_IsGamer', 'HasDetections', 'Census_OSWUAutoUpdateOptionsName', 
                            'Census_GenuineStateName', 'Census_ActivationChannel']
     attributes = train.columns.tolist()
     #attributes.remove(target)
      
     for items in attributes:
         if items not in attributes_to_keep:
             train.drop(items, axis=1, inplace=True)
     array = train.values
     X = array[:,3:5]
     Y = array[:,9]
     
     
     imputer_x = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
     imputer_x = imputer_x.fit(X)
     X = imputer_x.transform(X)
     X=X.astype('int')
     Y=Y.astype('int')
     test_size = 0.33
     seed = 7
     X_train, X_test, Y_train, Y_test = model_selection.train_test_split(X, Y, test_size=test_size, random_state=seed)
     print(X_train, X_test, Y_train, Y_test)
     # Fit the model on 33%
     
     #model = LogisticRegression()
     self.model.fit(X_train, Y_train)


  #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
  #This function must return the predicted probabilities for the test machines
  def predict_probablities(self, test_data):
     data = test_data
     attributes_to_keep = ['ProductName', 'Platform', 'SkuEdition', 'IsProtected', 'Firewall',
                            'Wdft_IsGamer', 'Census_OSWUAutoUpdateOptionsName', 
                            'Census_GenuineStateName', 'Census_ActivationChannel', 'HasDetections']
     attributes = data.columns.tolist()
     #attributes.remove(target)
      
     for items in attributes:
         if items not in attributes_to_keep:
             data.drop(items, axis=1, inplace=True)
     array = data.values
     X = array[:,3:5]
     imputer_x = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
     imputer_x = imputer_x.fit(X)
     X = imputer_x.transform(X)
     X=X.astype('int')
     
      
     predictions = self.model.predict(X)
     print('Predict malware')

     return predictions


#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    test_with_labels = pd.read_csv('testfile.csv',dtype=detectionModel.dtypes)
    test = test_with_labels.drop('HasDetections', axis=1)
    predictions = detectionModel.predict_probablities(test)
    print(predictions)
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()